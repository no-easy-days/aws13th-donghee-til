Import: 요리 재료를 냉장고에서 꺼내는 행위

Pip: 식자재 마트에서 재료를 사 와서 냉장고에 채워 넣는 주문 시스템

Venv (가상환경): 프로젝트마다 따로 쓰는 전용 냉장고/ 사용 이유 원하는 버전을 서로 간섭하지 않고 자유롭게 사용 가능

## 일급 객체
함수는 요리 레시피 즉 물건이다. 주머니(변수)에 넣을 수도 있고, 친구에게 줄 수도(인자로 전달), 선물로 받을 수도(리턴값) 있다 이걸 어려운 말로 일급 객체라고 함

```
def shout(text):
    return text.upper() + "!!!"

def whisper(text):
    return text.lower() + "..."

# 1. 함수를 변수처럼 주고받기 (함수를 인자로 전달)
def speak(func, message):
    # func라는 변수 안에 shout나 whisper 함수가 들어옴
    print(func(message))

speak(shout, "hello")   # 출력: HELLO!!!
speak(whisper, "HELLO") # 출력: hello...
```

결론 모든 함수는 일급 객체임

다른 함수를 인자로 받는 함수 

함수를 리턴하는 함수 

이 두가지 중 하나 이상을 해야만 고차 함수임

## 클로저
함수 안에 함수를 만들었을 때 안쪽 함수가 바깥쪽 함수의 변수를 기억하고 있는 현상

보통 함수는 할 일이 끝나면 그 안의 변수는 사라짐 이걸 메모리 해제라고 함 하지만 클로저는 배낭을 멘 것처럼 자신이 만들어질 때의 변수을 챙겨서 나옴

```
def shout(text):
    return text.upper() + "!!!"

def whisper(text):
    return text.lower() + "..."

# 1. 함수를 변수처럼 주고받기 (함수를 인자로 전달)
def speak(func, message):
    # func라는 변수 안에 shout나 whisper 함수가 들어옴
    print(func(message))

speak(shout, "hello")   # 출력: HELLO!!!
speak(whisper, "HELLO") # 출력: hello...
```

## 데코레이터
 일급 객체와 클로저를 합쳐서 만든거
 
 기존 함수를 수정하지 않고, 앞뒤에 부가적인 기능을 추가하고 싶을 때 사용 즉 선물주고 싶은데 그냥 주기 좀 그래서 이쁘게 포장하는것
 
 @를 붙이는 건, 내 함수를 리모델링 업체에 맡겨서 앞뒤로 기능을 덧붙인 새로운 함수로 바꿔치기하는 것이다."


```
def my_decorator(func):
    def wrapper():
        print("=== 시작 전: 준비 운동 ===") # 추가된 기능 1
        func()                         # 원본 함수 실행
        print("=== 끝난 후: 정리 운동 ===") # 추가된 기능 2
    return wrapper

# 2. @ 기호로 적용 (갑옷 착용!)
@my_decorator
def say_hello():
    print("안녕하세요!")

# 3. 실행
say_hello()

# 실행결과
=== 시작 전: 준비 운동 ===
안녕하세요!
=== 끝난 후: 정리 운동 ===
```





