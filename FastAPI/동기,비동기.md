## 동시성/병렬성
### 동시성
일손은 하나지만 여러 작업을 번갈아 처리해서 보는 입장에선 마치 동시에 돌아가는 것처럼 보입니다.(비동기)
### 병렬성
일손이 여러 개라서 진짜 동시에 여러 일을 처리한다

## 동기/비동기
### 동기
지금 진행중인 일이 완전히 다 끝나야 다른일을 시작할 수 있다 중간에 다른 일❌

### 비동기
지금 진행중인 일이 다 안끝나도 중간에 다른 일 처리가 가능하다

데이터를 주고 받을때 생기는 기다리는 시간 동안 다른 일 가능


## 동시성이 좋은 경우: 기다리는 시간이 많을 때

웹 서버는 대부분 기다림입니다.

- 데이터베이스에서 데이터 가져오기
- 외부 API 호출하기
- 파일 읽고 쓰기

이런 작업을 ***I/O 바운드(I/O bound)*** 작업이라고 부릅니다.

## I/O 바운드란?

- **I/O** = Input/Output (입출력). 데이터를 주고받는 것
- **bound** = "~에 묶여 있다"

"입출력에 묶여 있다"는 뜻입니다. 프로그램이 직접 계산하는 게 아니라, 외부에서 데이터가 오기를 기다리느라 시간이 걸리는 작업입니다.


## 병렬성이 좋은 경우: 할 일이 많을 때

집 대청소를 생각해보세요. 기다릴 게 없고, 그냥 청소만 하면 됩니다.

혼자 방 하나씩 청소하나, 번갈아 청소하나 걸리는 시간은 같습니다. 친구 8명이 와서 각자 한 방씩 청소하면? 훨씬 빨리 끝납니다.

이런 작업을 "CPU 바운드(CPU bound)" 작업이라고 부릅니다.


## CPU 바운드란?

- **CPU** = 컴퓨터의 두뇌. 계산을 담당하는 부품
- **bound** = "~에 묶여 있다"

"CPU에 묶여 있다"는 뜻입니다. 외부를 기다리는 게 아니라, CPU가 직접 열심히 계산해야 하는 작업입니다.

FAST API는 둘다 사용 가능

## async와 await 사용법

```
# 일반 함수 - 지금까지 배운 방식
def make_ramen():
    return "라면 완성"


# 비동기 함수 - async를 앞에 붙임
async def make_ramen_async():
    return "라면 완성"
```
**async**는 "이 함수는 중간에 기다리는 시간이 있을 수 있어요"라고 알려주는 표시입니다

### await는 언제 쓰나요?

**await**는 "여기서 잠깐 기다려야 해요"라고 표시하는 것입니다.
```
async def order_food():
    # await = "이 작업이 끝날 때까지 기다려요"
    # 기다리는 동안 다른 일을 할 수 있게 해줍니다
    food = await get_food_from_kitchen()
    return food
```
### 핵심 규칙 2가지
1. `await`는 `async def` 함수 안에서만 쓸 수 있습니다
2. `async def`로 만든 함수를 부를 때는 `await`를 붙여야 합니다

## FastAPI에서 실제로 쓰는 법

### 방법 1: 그냥 def 쓰기 (가장 쉬움)

```python
from fastapi import FastAPI

app = FastAPI()

# 평범하게 def로 만들면 됩니다
# FastAPI가 알아서 처리해줍니다
@app.get("/hello")
def say_hello():
    return {"message": "안녕하세요"}
```

### 방법 2: async def 쓰기

```python
from fastapi import FastAPI

app = FastAPI()

# async def로 만들어도 됩니다
# await를 쓸 일이 있으면 이렇게 합니다
@app.get("/hello")
async def say_hello():
    return {"message": "안녕하세요"}
```
### async def, def 언제 써야되는지 모르갰으면 처음에는 def 사용하자!














